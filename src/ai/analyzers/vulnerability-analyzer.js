/**
 * AI-Powered Vulnerability Assessment Engine
 * Analyzes security scan results to identify complex vulnerabilities
 */

import AIService from '../core/ai-service.js';

class VulnerabilityAnalyzer extends AIService {
  constructor(options = {}) {
    super(options);
    this.name = 'VulnerabilityAnalyzer';
    this.version = '1.0.0';
    
    // Vulnerability scoring weights
    this.weights = {
      ssl: 0.25,
      headers: 0.20,
      threats: 0.30,
      techStack: 0.15,
      ports: 0.10
    };

    // Vulnerability patterns and rules
    this.vulnerabilityRules = this.initializeVulnerabilityRules();
  }

  /**
   * Initialize vulnerability detection rules
   */
  initializeVulnerabilityRules() {
    return {
      critical: [
        {
          name: 'Expired SSL Certificate',
          pattern: (data) => data.ssl?.valid === false || this.isSSLExpired(data.ssl),
          score: 9.5,
          description: 'SSL certificate is expired or invalid',
          remediation: 'Renew SSL certificate immediately'
        },
        {
          name: 'Known Malware/Phishing Site',
          pattern: (data) => data.threats?.unsafe === true,
          score: 10.0,
          description: 'Site flagged as malware or phishing by threat intelligence',
          remediation: 'Investigate and clean infected content immediately'
        },
        {
          name: 'Missing Critical Security Headers',
          pattern: (data) => this.hasCriticalHeaderIssues(data.headers),
          score: 8.5,
          description: 'Critical security headers are missing',
          remediation: 'Implement Content-Security-Policy, X-Frame-Options, and HSTS headers'
        }
      ],
      high: [
        {
          name: 'Weak SSL Configuration',
          pattern: (data) => this.hasWeakSSLConfig(data.ssl),
          score: 7.5,
          description: 'SSL configuration uses weak ciphers or protocols',
          remediation: 'Update SSL configuration to use strong ciphers and TLS 1.2+'
        },
        {
          name: 'Vulnerable Technology Stack',
          pattern: (data) => this.hasVulnerableTechStack(data.techStack),
          score: 8.0,
          description: 'Detected technologies with known vulnerabilities',
          remediation: 'Update vulnerable components to latest secure versions'
        },
        {
          name: 'Open Dangerous Ports',
          pattern: (data) => this.hasDangerousOpenPorts(data.ports),
          score: 7.0,
          description: 'Dangerous ports are open and accessible',
          remediation: 'Close unnecessary ports and implement proper firewall rules'
        }
      ],
      medium: [
        {
          name: 'Incomplete Security Headers',
          pattern: (data) => this.hasIncompleteSecurityHeaders(data.headers),
          score: 5.5,
          description: 'Some security headers are missing or misconfigured',
          remediation: 'Implement additional security headers for defense in depth'
        },
        {
          name: 'Information Disclosure',
          pattern: (data) => this.hasInformationDisclosure(data.headers, data.techStack),
          score: 6.0,
          description: 'Server reveals sensitive information in headers or responses',
          remediation: 'Remove or obfuscate server version information'
        }
      ],
      low: [
        {
          name: 'Suboptimal SSL Configuration',
          pattern: (data) => this.hasSuboptimalSSL(data.ssl),
          score: 3.5,
          description: 'SSL configuration could be improved',
          remediation: 'Consider implementing HSTS preload and certificate transparency'
        }
      ]
    };
  }

  /**
   * Perform vulnerability analysis on security scan data
   * @param {Object} data - Combined security scan data
   * @param {string} analysisType - Type of analysis
   * @returns {Promise<Object>} Vulnerability analysis results
   */
  async performAnalysis(data, analysisType = 'comprehensive') {
    console.log('🔍 Starting AI vulnerability analysis...');

    try {
      // Validate input data
      this.validateInputData(data);

      // Detect vulnerabilities using rules engine
      const vulnerabilities = await this.detectVulnerabilities(data);

      // Calculate overall risk score
      const riskScore = this.calculateRiskScore(vulnerabilities);

      // Generate recommendations
      const recommendations = this.generateRecommendations(vulnerabilities, data);

      // Create insights
      const insights = this.generateInsights(vulnerabilities, data);

      // Calculate confidence based on data completeness
      const confidence = this.calculateConfidence(data, vulnerabilities);

      const result = {
        vulnerabilities,
        riskScore,
        riskLevel: this.getRiskLevel(riskScore),
        recommendations,
        insights,
        confidence,
        summary: this.generateSummary(vulnerabilities, riskScore),
        affectedComponents: this.getAffectedComponents(vulnerabilities),
        prioritizedActions: this.prioritizeActions(recommendations)
      };

      console.log(`✅ Vulnerability analysis complete. Risk Score: ${riskScore}/10`);
      return result;

    } catch (error) {
      console.error('❌ Vulnerability analysis failed:', error);
      throw error;
    }
  }

  /**
   * Validate input data for analysis
   * @param {Object} data - Input data
   */
  validateInputData(data) {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid input data for vulnerability analysis');
    }

    // Check for required data types
    const requiredFields = ['url'];
    for (const field of requiredFields) {
      if (!data[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }
  }

  /**
   * Detect vulnerabilities using rules engine
   * @param {Object} data - Security scan data
   * @returns {Array} Detected vulnerabilities
   */
  async detectVulnerabilities(data) {
    const vulnerabilities = [];

    // Check each severity level
    for (const [severity, rules] of Object.entries(this.vulnerabilityRules)) {
      for (const rule of rules) {
        try {
          if (rule.pattern(data)) {
            vulnerabilities.push({
              id: this.generateVulnerabilityId(rule.name),
              name: rule.name,
              severity,
              score: rule.score,
              description: rule.description,
              remediation: rule.remediation,
              detectedAt: new Date().toISOString(),
              affectedComponent: this.identifyAffectedComponent(rule.name),
              evidence: this.gatherEvidence(data, rule)
            });
          }
        } catch (error) {
          console.warn(`⚠️ Error checking rule ${rule.name}:`, error.message);
        }
      }
    }

    return vulnerabilities.sort((a, b) => b.score - a.score);
  }

  /**
   * Calculate overall risk score
   * @param {Array} vulnerabilities - Detected vulnerabilities
   * @returns {number} Risk score (0-10)
   */
  calculateRiskScore(vulnerabilities) {
    if (vulnerabilities.length === 0) return 0;

    // Weight vulnerabilities by severity
    const severityWeights = { critical: 1.0, high: 0.7, medium: 0.4, low: 0.2 };
    
    let totalScore = 0;
    let maxPossibleScore = 0;

    vulnerabilities.forEach(vuln => {
      const weight = severityWeights[vuln.severity] || 0.1;
      totalScore += vuln.score * weight;
      maxPossibleScore += 10 * weight;
    });

    // Normalize to 0-10 scale
    const normalizedScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 10 : 0;
    
    return Math.min(Math.round(normalizedScore * 10) / 10, 10);
  }

  /**
   * Generate security recommendations
   * @param {Array} vulnerabilities - Detected vulnerabilities
   * @param {Object} data - Original scan data
   * @returns {Array} Recommendations
   */
  generateRecommendations(vulnerabilities, data) {
    const recommendations = [];

    // Group vulnerabilities by component
    const componentVulns = this.groupVulnerabilitiesByComponent(vulnerabilities);

    for (const [component, vulns] of Object.entries(componentVulns)) {
      const highestSeverity = vulns.reduce((max, v) => v.score > max ? v.score : max, 0);
      
      recommendations.push({
        component,
        priority: this.getPriorityFromScore(highestSeverity),
        actions: vulns.map(v => v.remediation),
        estimatedEffort: this.estimateEffort(vulns),
        businessImpact: this.assessBusinessImpact(vulns, data)
      });
    }

    return recommendations.sort((a, b) => b.priority - a.priority);
  }

  /**
   * Generate AI insights
   * @param {Array} vulnerabilities - Detected vulnerabilities
   * @param {Object} data - Original scan data
   * @returns {Array} Insights
   */
  generateInsights(vulnerabilities, data) {
    const insights = [];

    // Trend analysis
    if (vulnerabilities.length > 5) {
      insights.push({
        type: 'trend',
        message: 'High number of vulnerabilities detected. Consider a comprehensive security audit.',
        severity: 'warning'
      });
    }

    // Technology-specific insights
    if (data.techStack?.technologies) {
      const outdatedTech = this.identifyOutdatedTechnologies(data.techStack.technologies);
      if (outdatedTech.length > 0) {
        insights.push({
          type: 'technology',
          message: `Outdated technologies detected: ${outdatedTech.join(', ')}`,
          severity: 'info'
        });
      }
    }

    // Security posture insights
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      insights.push({
        type: 'security',
        message: `${criticalVulns.length} critical vulnerabilities require immediate attention`,
        severity: 'critical'
      });
    }

    return insights;
  }

  // Helper methods for vulnerability detection rules

  isSSLExpired(sslData) {
    if (!sslData?.valid_to) return false;
    const expiryDate = new Date(sslData.valid_to);
    return expiryDate < new Date();
  }

  hasCriticalHeaderIssues(headers) {
    if (!headers) return true;
    
    const criticalHeaders = [
      'content-security-policy',
      'x-frame-options',
      'strict-transport-security'
    ];
    
    return criticalHeaders.some(header => !headers[header]);
  }

  hasWeakSSLConfig(sslData) {
    if (!sslData) return true;
    
    // Check for weak protocols or ciphers
    const weakProtocols = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1'];
    const protocol = sslData.protocol || '';
    
    return weakProtocols.some(weak => protocol.includes(weak));
  }

  hasVulnerableTechStack(techStack) {
    if (!techStack?.technologies) return false;
    
    // Simple check for known vulnerable versions
    const vulnerableTech = [
      'jQuery 1.', 'jQuery 2.', 'Angular 1.', 'React 15.', 'Vue 1.'
    ];
    
    return techStack.technologies.some(tech => 
      vulnerableTech.some(vuln => tech.name?.includes(vuln))
    );
  }

  hasDangerousOpenPorts(ports) {
    if (!ports?.open) return false;
    
    const dangerousPorts = [21, 23, 135, 139, 445, 1433, 3389];
    return ports.open.some(port => dangerousPorts.includes(port.port));
  }

  hasIncompleteSecurityHeaders(headers) {
    if (!headers) return true;
    
    const recommendedHeaders = [
      'x-content-type-options',
      'x-xss-protection',
      'referrer-policy'
    ];
    
    return recommendedHeaders.some(header => !headers[header]);
  }

  hasInformationDisclosure(headers, techStack) {
    if (!headers) return false;
    
    const disclosureHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
    return disclosureHeaders.some(header => headers[header]);
  }

  hasSuboptimalSSL(sslData) {
    if (!sslData) return false;
    
    // Check for missing HSTS preload or other optimizations
    return !sslData.hsts_preload || !sslData.certificate_transparency;
  }

  // Utility methods

  generateVulnerabilityId(name) {
    return `vuln_${name.toLowerCase().replace(/\s+/g, '_')}_${Date.now()}`;
  }

  identifyAffectedComponent(ruleName) {
    const componentMap = {
      'SSL': ['ssl', 'certificate', 'tls'],
      'Headers': ['header', 'security header'],
      'Network': ['port', 'firewall'],
      'Application': ['tech', 'technology', 'framework']
    };

    for (const [component, keywords] of Object.entries(componentMap)) {
      if (keywords.some(keyword => ruleName.toLowerCase().includes(keyword))) {
        return component;
      }
    }
    
    return 'Unknown';
  }

  gatherEvidence(data, rule) {
    // Gather relevant evidence for the vulnerability
    const evidence = {};
    
    if (rule.name.includes('SSL')) {
      evidence.ssl = data.ssl;
    }
    if (rule.name.includes('Header')) {
      evidence.headers = data.headers;
    }
    if (rule.name.includes('Threat')) {
      evidence.threats = data.threats;
    }
    
    return evidence;
  }

  getRiskLevel(score) {
    if (score >= 8) return 'Critical';
    if (score >= 6) return 'High';
    if (score >= 4) return 'Medium';
    if (score >= 2) return 'Low';
    return 'Minimal';
  }

  calculateConfidence(data, vulnerabilities) {
    let confidence = 0.5; // Base confidence
    
    // Increase confidence based on data completeness
    const dataFields = ['ssl', 'headers', 'threats', 'techStack', 'ports'];
    const availableFields = dataFields.filter(field => data[field]);
    confidence += (availableFields.length / dataFields.length) * 0.3;
    
    // Increase confidence based on vulnerability detection consistency
    if (vulnerabilities.length > 0) {
      confidence += 0.2;
    }
    
    return Math.min(confidence, 1.0);
  }

  generateSummary(vulnerabilities, riskScore) {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    
    return {
      totalVulnerabilities: vulnerabilities.length,
      criticalVulnerabilities: criticalCount,
      highVulnerabilities: highCount,
      overallRisk: this.getRiskLevel(riskScore),
      riskScore,
      summary: `Detected ${vulnerabilities.length} vulnerabilities with ${criticalCount} critical and ${highCount} high severity issues.`
    };
  }

  getAffectedComponents(vulnerabilities) {
    const components = new Set();
    vulnerabilities.forEach(v => components.add(v.affectedComponent));
    return Array.from(components);
  }

  prioritizeActions(recommendations) {
    return recommendations
      .flatMap(rec => rec.actions.map(action => ({
        action,
        component: rec.component,
        priority: rec.priority,
        effort: rec.estimatedEffort
      })))
      .sort((a, b) => b.priority - a.priority)
      .slice(0, 5); // Top 5 actions
  }

  groupVulnerabilitiesByComponent(vulnerabilities) {
    return vulnerabilities.reduce((groups, vuln) => {
      const component = vuln.affectedComponent;
      if (!groups[component]) groups[component] = [];
      groups[component].push(vuln);
      return groups;
    }, {});
  }

  getPriorityFromScore(score) {
    if (score >= 8) return 5; // Critical
    if (score >= 6) return 4; // High
    if (score >= 4) return 3; // Medium
    if (score >= 2) return 2; // Low
    return 1; // Minimal
  }

  estimateEffort(vulnerabilities) {
    const effortMap = { critical: 8, high: 5, medium: 3, low: 1 };
    const totalEffort = vulnerabilities.reduce((sum, v) => sum + (effortMap[v.severity] || 1), 0);
    
    if (totalEffort > 20) return 'High';
    if (totalEffort > 10) return 'Medium';
    return 'Low';
  }

  assessBusinessImpact(vulnerabilities, data) {
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical').length;
    
    if (criticalVulns > 0) return 'High';
    if (vulnerabilities.length > 5) return 'Medium';
    return 'Low';
  }

  identifyOutdatedTechnologies(technologies) {
    const outdated = [];
    
    technologies.forEach(tech => {
      if (tech.version && this.isVersionOutdated(tech.name, tech.version)) {
        outdated.push(`${tech.name} ${tech.version}`);
      }
    });
    
    return outdated;
  }

  isVersionOutdated(name, version) {
    // Simple heuristic - in production, this would use a vulnerability database
    const majorVersion = parseInt(version.split('.')[0]);
    
    const outdatedVersions = {
      'jQuery': 3,
      'Angular': 12,
      'React': 16,
      'Vue.js': 2
    };
    
    return outdatedVersions[name] && majorVersion < outdatedVersions[name];
  }
}

export default VulnerabilityAnalyzer;
