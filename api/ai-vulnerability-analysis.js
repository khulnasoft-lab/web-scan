/**
 * AI Vulnerability Analysis API Endpoint
 * Provides AI-powered vulnerability assessment for websites
 */

import VulnerabilityAnalyzer from '../src/ai/analyzers/vulnerability-analyzer.js';
import middleware from './_common/middleware.js';

// Import existing security analysis APIs
import { handler as sslHandler } from './security/ssl.js';
import { handler as headersHandler } from './security/headers.js';
import { handler as threatsHandler } from './security/threats.js';
import { handler as techStackHandler } from './analysis/tech-stack.js';
import { handler as portsHandler } from './network/ports.js';

// Initialize AI analyzer
const vulnerabilityAnalyzer = new VulnerabilityAnalyzer({
  confidenceThreshold: 0.7,
  enableLearning: process.env.NODE_ENV === 'development'
});

// Initialize the analyzer
vulnerabilityAnalyzer.initialize().catch(console.error);

/**
 * Main AI vulnerability analysis handler
 * @param {string} url - URL to analyze
 * @param {Object} options - Analysis options
 * @returns {Promise<Object>} AI vulnerability analysis results
 */
const aiVulnerabilityAnalysisHandler = async (url, options = {}) => {
  try {
    console.log(`ü§ñ Starting AI vulnerability analysis for: ${url}`);
    
    // Validate URL
    if (!url) {
      throw new Error('URL is required for vulnerability analysis');
    }

    try {
      new URL(url);
    } catch {
      throw new Error('Invalid URL format');
    }

    // Gather security data from existing APIs
    const securityData = await gatherSecurityData(url, options);

    // Perform AI analysis
    const aiAnalysis = await vulnerabilityAnalyzer.analyze(securityData, 'comprehensive');

    // Combine results
    const result = {
      success: true,
      url,
      timestamp: new Date().toISOString(),
      aiAnalysis,
      rawData: options.includeRawData ? securityData : undefined,
      metadata: {
        analysisVersion: vulnerabilityAnalyzer.version,
        processingTime: aiAnalysis.metadata?.processingTime,
        confidence: aiAnalysis.confidence,
        dataCompleteness: calculateDataCompleteness(securityData)
      }
    };

    console.log(`‚úÖ AI vulnerability analysis completed for ${url}`);
    console.log(`üìä Risk Score: ${aiAnalysis.riskScore}/10 (${aiAnalysis.riskLevel})`);
    console.log(`üîç Found ${aiAnalysis.vulnerabilities.length} vulnerabilities`);

    return result;

  } catch (error) {
    console.error('‚ùå AI vulnerability analysis failed:', error);
    
    return {
      success: false,
      error: error.message,
      url,
      timestamp: new Date().toISOString(),
      metadata: {
        analysisVersion: vulnerabilityAnalyzer.version,
        errorType: error.name || 'UnknownError'
      }
    };
  }
};

/**
 * Gather security data from all available APIs
 * @param {string} url - URL to analyze
 * @param {Object} options - Analysis options
 * @returns {Promise<Object>} Combined security data
 */
async function gatherSecurityData(url, options = {}) {
  const securityData = { url };
  const gatheringPromises = [];

  // SSL Analysis
  if (options.includeSsl !== false) {
    gatheringPromises.push(
      gatherDataSafely('ssl', () => sslHandler(url))
        .then(data => securityData.ssl = data)
    );
  }

  // Headers Analysis
  if (options.includeHeaders !== false) {
    gatheringPromises.push(
      gatherDataSafely('headers', () => headersHandler(url))
        .then(data => securityData.headers = data)
    );
  }

  // Threat Analysis
  if (options.includeThreats !== false) {
    gatheringPromises.push(
      gatherDataSafely('threats', () => threatsHandler(url))
        .then(data => securityData.threats = data)
    );
  }

  // Technology Stack Analysis
  if (options.includeTechStack !== false) {
    gatheringPromises.push(
      gatherDataSafely('techStack', () => techStackHandler(url))
        .then(data => securityData.techStack = data)
    );
  }

  // Port Scanning (if enabled)
  if (options.includePorts === true) {
    gatheringPromises.push(
      gatherDataSafely('ports', () => portsHandler(url))
        .then(data => securityData.ports = data)
    );
  }

  // Wait for all data gathering to complete
  await Promise.allSettled(gatheringPromises);

  return securityData;
}

/**
 * Safely gather data from an API handler
 * @param {string} dataType - Type of data being gathered
 * @param {Function} handler - API handler function
 * @returns {Promise<any>} Data or null if failed
 */
async function gatherDataSafely(dataType, handler) {
  try {
    const startTime = Date.now();
    const data = await handler();
    const processingTime = Date.now() - startTime;
    
    console.log(`‚úÖ ${dataType} data gathered in ${processingTime}ms`);
    return data;
  } catch (error) {
    console.warn(`‚ö†Ô∏è Failed to gather ${dataType} data:`, error.message);
    return null;
  }
}

/**
 * Calculate data completeness percentage
 * @param {Object} securityData - Gathered security data
 * @returns {number} Completeness percentage (0-100)
 */
function calculateDataCompleteness(securityData) {
  const expectedFields = ['ssl', 'headers', 'threats', 'techStack'];
  const availableFields = expectedFields.filter(field => securityData[field] !== null);
  return Math.round((availableFields.length / expectedFields.length) * 100);
}

/**
 * Enhanced handler with additional features
 */
const enhancedHandler = async (url, event, context) => {
  const startTime = Date.now();
  
  try {
    // Parse query parameters for options
    const options = {
      includeRawData: event?.queryStringParameters?.includeRawData === 'true',
      includeSsl: event?.queryStringParameters?.includeSsl !== 'false',
      includeHeaders: event?.queryStringParameters?.includeHeaders !== 'false',
      includeThreats: event?.queryStringParameters?.includeThreats !== 'false',
      includeTechStack: event?.queryStringParameters?.includeTechStack !== 'false',
      includePorts: event?.queryStringParameters?.includePorts === 'true'
    };

    const result = await aiVulnerabilityAnalysisHandler(url, options);
    
    // Add total processing time
    result.metadata = {
      ...result.metadata,
      totalProcessingTime: Date.now() - startTime
    };

    return result;
  } catch (error) {
    return {
      success: false,
      error: error.message,
      url,
      timestamp: new Date().toISOString(),
      metadata: {
        totalProcessingTime: Date.now() - startTime,
        errorType: error.name || 'UnknownError'
      }
    };
  }
};

// Export handlers
export const handler = middleware(enhancedHandler);
export default handler;

// Export the analyzer instance for use in other modules
export { vulnerabilityAnalyzer };
